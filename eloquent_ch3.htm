<html>

<body>


    <script>
        // Find the exponent

        const power = function(base, exponent) {
            let result = 1;
            for (let count = 0; count < exponent; count++) {
                result *= base;
            }
            return result;
        }
        console.log(power(2, 10));

        // Scope
        // Bindings declared with let and const are local to the block they 
        // are declared in.

        let x = 10;
        if (true) {
            let y = 20;
            var z = 30;
            console.log(x + y + z);
        }
        // y is not visible here, outside the function.
        console.log(x + z);

        // Don't give local and global variables the same name. 
        const halve = function(n) {
            return n / 2;
        };

        let n = 10;
        console.log(halve(100));
        // → 50
        console.log(n);
        // → 10

        // The hummus recipe function that contains another function

        const hummus = function(factor) {
            const ingredient = function(amount, unit, name) {
                let ingredientAmount = amount * factor;
                if (ingredientAmount > 1) {
                    unit += "s";
                }
                console.log(`${ingredientAmount} ${unit} ${name}`);
            };
            // unit and ingredientAmount are not visible to the outer function
            // They call it lexical scoping.

            ingredient(1, "can", "chickpeas");
            ingredient(0.25, "cup", "tahini");
            ingredient(0.25, "cup", "lemon juice");
            ingredient(1, "clove", "garlic");
            ingredient(2, "tablespoon", "olive oil");
            ingredient(0.5, "teaspoon", "cumin");
        };

        // Function binding
        // usually it's a name for a specific piece of the program, that is defined 
        // once and never changed. The book gives this example (safeMode is not defined):

        // let launchMissiles = function() {
        //     missileSystem.launch("now");
        // };
        // if (safeMode) {
        //     launchMissiles = function() { /* do nothing */ };
        // }
        // MDN says The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.


        // Closure = Being able to reference a specific instance of a local binding in an enclosed scope.

        // What happens to local bindings when the function call that created them is no longer active?

        // The following code shows an example of this. It defines a function, wrapValue, that creates a local binding. It then returns a function that accesses and returns this local binding.

        function wrapValue(n) {
            let local = n; // You don't need to say this because n is already local
            return () => local;
        }

        let wrap1 = wrapValue(1);
        let wrap2 = wrapValue(2);
        console.log(wrap1());
        // → 1
        console.log(wrap2());
        // → 2

        // This one multiplies by an arbitrary amount:
        function multiplier(factor) {
            return number => number * factor;
        }

        let twice = multiplier(2);
        console.log(twice(5));
        // → 10
    </script>
</body>

</html>